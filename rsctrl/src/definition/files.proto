package rsctrl.files;

import "core.proto";

///////////////////////////////////////////////////////////////
// Mirror most of rsFiles functionality.
//
// Share Directories.
// Searches
// List Transfers.
// Control Transfers.
///////////////////////////////////////////////////////////////

enum RequestMsgIds {
    MsgId_RequestPeers = 1;
    MsgId_RequestAddPeer = 2;
    MsgId_RequestModifyPeer = 3;
}

enum ResponseMsgIds {
    MsgId_ResponsePeerList = 1;
    MsgId_ResponseAddPeer = 2;
    MsgId_ResponseModifyPeer = 3;
}

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// SEARCH (start).

// REQUEST: RequestBasicSearch
message RequestBasicSearch {

  repeated string terms = 1;
}

// REQUEST: RequestAdvSearch
message RequestAdvSearch {

  repeated string terms = 1;
}


// RESPONSE: ResponseSearchId
message ResponseSearchId {

  required rsctrl.core.Status status = 1;
  required string search_id = 2;
}

///////////////////////////////////////////////////////////////
// SEARCH (list)


// REQUEST: RequestSearchResults
message RequestSearchResults {

  enum SetCmd {
    ALLIDS = 1; 	// All 
    LISTED = 2; 	// Only Search Ids in the Vector.
  }

  required SetCmd set = 1;
  repeated string search_ids = 2;
}

// Building Block
message SearchHit {

  enum LocFlag {
    LOCAL 	= 1; 	// We Have it.
    FRIEND 	= 2; 	// Browsable
    NETWORK 	= 4; 	// Network.
  }

  required rsctrl.core.File file 	= 1;
  required int no_hits 			= 2
  required LocFlag loc 			= 3;

}

message SearchSet {

  required string search_id			= 1;

  enum SearchType {
    BASIC 	= 1; 	// Stuff.
    ADVANCED 	= 2; 	// Stuff.
  }

  // One of these will be filled in depending on flag.

  required SearchType         search_type	= 2;
  optional RequestBasicSearch basic_req		= 3;
  optional RequestAdvSearch   adv_req		= 4;

  repeated SearchHit				= 5;

}

// RESPONSE: ResponseSearchResults
message ResponseSearchResults {

  required rsctrl.core.Status status = 1;
  repeated SearchSet searches = 2;
}


///////////////////////////////////////////////////////////////
// SEARCH (cancel)

// REQUEST: RequestCloseSearch
message RequestCloseSearch {

  required string search_id = 2;
}


// RESPONSE: ResponseSearchId
// As before.


///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// SHARED FILES



// REQUEST: RequestListShares
message RequestListShares {

  required int depth = 1;		// HOW Many Directories to drill down.
  repeated string ShareLocation = 2;
}

message ShareLocation {
  required string ssl_id = 1;
  required string path = 2;
}

message 



// REQUEST: RequestChangeShares

// REQUEST: RequestLiCloseSearch
// REQUEST: RequestCloseSearch




// REQUEST: RequestAddPeer
message RequestAddPeer {

  enum AddCmd {
    NOOP = 0; 		// No op.
    ADD = 1; 		// Add existing from gpg_id.
    REMOVE = 2; 	// Remove existing from gpg_id.
    IMPORT = 3; 	// Import from cert, with gpg_id.
    EXAMINE = 4; 	// Examine cert, but no action.
  }

  required string gpg_id = 1;
  required AddCmd cmd = 2;
  optional string cert = 3;
}

// RESPONSE: ResponseAddPeer
message ResponseAddPeer {
  required rsctrl.core.Status status = 1;
  repeated rsctrl.core.Person peers = 2;
}

///////////////////////////////////////////////////////////////

// REQUEST: RequestModifyPeer
message RequestModifyPeer {

  enum ModCmd {
    NOOP    		= 0; 	
    ADDRESS 		= 1;
    DYNDNS  		= 2;
    //SOMETHING_ELSE  	= 0x0000010; 
    //SOMETHING_ELSE  	= 0x0000020; 
    //SOMETHING_ELSE  	= 0x0000040; 
    //SOMETHING_ELSE  	= 0x0000080; 
  }

  required ModCmd cmd = 1; 
  //required int64 cmd = 1; // Could we OR the Cmds together?
  repeated rsctrl.core.Person peers = 2;
}

// RESPONSE: ResponseModifyPeer
message ResponseModifyPeer {
  required rsctrl.core.Status status = 1;
  repeated rsctrl.core.Person peers = 2;
}

///////////////////////////////////////////////////////////////

